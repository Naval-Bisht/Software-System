/*
============================================================================================
File Name : 26.c
Author : Naval Kishore Singh Bisht
Roll No : MT2024099
Description : 26. Write a program to send messages to the message queue. Check $ipcs -q
Data : 19/09/2024
============================================================================================
*/

#include <stdio.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>

struct message {
    long msg_type;
    char msg_text[100];
};

int main() {
    key_t key;
    int msqid;
    struct message msg;

    // Generate a unique key and get the message queue ID
    key = ftok("file26", 65);
    msqid = msgget(key, 0666 | IPC_CREAT);

    // Prepare the message
    msg.msg_type = 1;
    strcpy(msg.msg_text, "Hello, this is a message.");

    // Send the message
    msgsnd(msqid, &msg, sizeof(msg.msg_text), 0);
    printf("Message sent to the queue.\n");
// uncomment the 4 lins to check wheteher you send the message is working or not 
    //     // receive the message
    //  msgrcv(msqid, &msg, sizeof(msg.msg_text), 1, 0);

    // // Display the message
    // printf("Received message: %s\n", msg.msg_text);

    return 0;
}

/*
Explanation:
1. `msgsnd()` sends the message to the message queue.
2. The message type is set to 1, and the message content is "Hello, this is a message."
3. The message queue is identified by the `msqid`, which is obtained using `msgget()`.

For more details, use the following man pages:
- man 2 msgsnd
- man 2 ftok
- man 2 msgget
*/


// The msqid (message queue identifier) keeps increasing even after you remove a message queue using ipcrm -q because of how System V IPC (Interprocess Communication) handles the allocation of message queue IDs.

// Here’s why it happens:

//     Message Queue ID Allocation: The kernel uses a monotonically increasing counter for assigning message queue IDs (msqid). Even when you delete a message queue using ipcrm -q, the counter is not reset. The next time a new message queue is created using msgget(), the ID continues from where it left off.

//     Persistent Kernel State: The message queue identifiers are managed by the kernel, and it does not recycle the old IDs immediately. Instead, it continues to increment the ID, ensuring that each newly created queue has a unique ID, even if others were removed.

//     ftok() Key Reuse: While you are using the same key generated by ftok(), the msqid returned by msgget() will always be a new value. This is because msgget() looks for an existing message queue with the same key, and if it doesn’t find one (i.e., after you've deleted it), it creates a new message queue with a new msqid.

//     Kernel-Level Resource Management: The kernel tracks system-wide IPC resources (message queues, shared memory segments, semaphores). When you delete a message queue, it only removes the resource; it doesn't reset the internal counter that keeps track of how many message queues have been created